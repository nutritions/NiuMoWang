0011 000 000000000;                                 程序从x3000开始
0010 001 011111111;      x3000:     LD,R1,x0FF:     地址x3100的值存入R1中（A）
0010 010 011111111;      x3001:     LD,R2,x0FF:     地址x3101的值存入R2中（B）
0101 011 011 1 00000;    x3002:                     R3清零，储存数字1出现的次数
0101 100 100 1 00000;    x3003:     AND R4,R4,0：   R4清零
0001 100 100 1 01000;    x3004:     ADD R4,R4,8:   
0001 100 100 1 01000;    x3005:     ADD R4,R4,8:    R4连加两次8赋值为16（立即数范围不到16）
1001 010 010 111111;     x3006:     R2 <- NOT(B) 
0001 101 010 1 00001;    x3007:     R5 <- -B
0001 101 100 0 00 101;   X3008:     R5 <- 16-B      以上三步实现将16-B存入R5中，表示R1需要左移的次数
0000 010 000000011;      x3009:     BRz:            若R5为0，循环结束,跳转x300D
0001 001 001 0 00 001;   x300A:     ADD R1,R1,R1:   R1翻倍实现左移一位
0001 101 101 1 11111;    x300B:     ADD R5,R5,-1:   每移一位，R5循环减1，最终循环实现把低B位放在最高位
0000 111 111111100;      X300C:     BR：            判断R5是否为0,跳转到x3009
0010 010 011110011;      x300D:     LD,R2,x0F3:     将地址x3101的值存入R2中
0000 010 000000110;      x300E:     BRz:            若R2为0，循环结束,跳转x3015
0001 001 001 1 00000;    x300F:     ADD:R1,R1,0,    寄存器读取最近存入的树，所以对R1进行加0操作以便读取R1
0000 011 000000001;      x3010:     BRzp:           R1大于等于0，为正数则最高位为0，R3不变，跳转，否则为负数则表示最高位为1，不跳转
0001 011 011 1 00001;    x3011:     ADD R3,R3,1:    是1则R3加1
0001 010 010 1 11111;    x3012:     ADD R2,R2,-1:   循环次数减1，循环最终实现对B位数的判断
0001 001 001 0 00 001;   x3013:     ADD R1,R1,R1:   R1翻倍实现左移一位
0000 111 111111001;      X3014:     BR：            判断R2是否为0,跳转到x300E
0011 011 011101100;      x3015:     ST R3,x0EC：    R3存储到地址x3102中
1111 0000 00100101;      x3016:     halt            程序结束

