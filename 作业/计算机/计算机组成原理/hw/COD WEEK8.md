# COD WEEK8



## T1

> 题目 1. 现在一台电脑的处理器有32 bits的寻址空间，内存中的每个块的的大小为32 bytes，电脑的 cache 能够存储 16KIB 数据。 

### （1）

> 请问该电脑的 cache 能够存储多少个块？

$16KIB=2^{14}bytes$

一个块$32bytes=2^{5}bytes$

所以$2^{14}/2^5=512$



### （2）

> 假设该电脑的 cache 采用直接映射的方式，那么地址中TAG、Index、OFFSET的位 宽分别是多少？ 

OFFSET块内寻址，$32=2^5$，所以位宽为5

Index用于映射，共$512=2^9$个块，所以位宽为9

则TAG位宽为32-9-5=18



### （3）

> 如果采用的是 4 路组相联的方式，那么TAG、Index、OFFSET的位宽分别是多少？

4路组相联，则Index位宽有变动，$2^{9}/4=2^7$,所以位宽为7

OFFSET位宽不变为5

TAG位宽为32-7-5=20







## T2

> 题目 2. 现在我们有一个8bits寻址空间的计算机，内存中的每个块的大小为 8 bytes，计算机的 cache 能够存储 32B 数据。 cache 采用两路组相联的方式，采用 LRU 策略。现在 有以下访问序列：(Tag, Index, Offset均填入二进制）

同第一题分析，offset位宽为3，index位宽为1，TAG位宽为4


|  Address   | Tag  | Index | Offset | Hit/Miss/Replace | Miss Type  |
| :--------: | :--: | :---: | :----: | :--------------: | :--------: |
| 0b00000100 | 0000 |   0   |  100   |       miss       | Compulsory |
| 0b00000101 | 0000 |   0   |  101   |       hit        |    None    |
| 0b01101000 | 0110 |   1   |  000   |       miss       | Compulsory |
| 0b11001000 | 1100 |   1   |  000   |       miss       | Compulsory |
| 0b01101000 | 0110 |   1   |  000   |       hit        |    None    |
| 0b11011101 | 1101 |   1   |  101   |     replace      |  Conflict  |
| 0b01000010 | 0100 |   0   |  010   |       miss       | Compulsory |
| 0b00000100 | 0000 |   0   |  100   |       hit        |    None    |
| 0b11001000 | 1100 |   1   |  000   |     replace      |  Capacity  |



## T3

> 题目 3. 现在我们有一个32位字节寻址的 RISC-V 计算机，拥有 4 GiB 内存，一个 16 KiB 的 cache，每个 cache 块的大小为 32 byte 同时采用 LRU 策略。现在我们有如下的 C 代 码, 假定第一次运行时cache为空：
>
> ```c
> # define SIZE_A 2048
> typedef struct {
> 	int x ; // int 为 32 bits
> 	int y [ 3 ] ;
> } node ;
> int count ( node ∗A, int x ) { //为简化问题，A的首地址恰好位于一
> //个块的首地址
> 	int k = 0 ;
> 	for ( int i = 0 ; i < SIZE_A ; i++ ) {
> 	if (A[i].x == x ) {
> 		k ++;
> 	}
> 	}
> 	return k 
> }
> ```
>
> 在相同A在不同x下连续进行充分多次调用，回答下列问题：

共512个块

### (1)

> 采用直接映射，对A[i].x的访问是否会产生cache失效？如果会，会出现哪些失效？ 命中率是多少？

- 直接映射512个块，会失效
- 冲突失效和容量失效
- 命中率1/2



### (2)

> 如果采用8路组相联，对A[i].x的访问是否会产生cache失效？如果会，会出现哪些失效？命中率是多少？

- 8路组相联，64个，会失效，和1类似
- 冲突失效和容量失效
- 命中率1/2



### （3）

> 如果采用全相联映射且将cache的策略改为MRU，对A[i].x的访问是否会产生cache失效？如果会，会出现哪些失效？命中率大约是多少？

- 前511个块不变，512号块一直替换，会失效
- 替换512时冲突失效，多次调用count产生容量失效
- 命中率2/3



### （4）

> cache容量满后，出现的失效一定为容量失效吗？如果不是，举例说明

不一定，A[0-1023]写入cache后，第一次访问A[1024-2047]是冲突失效





### （5）

> 通过增加块的数量cache容量一定能提高命中率吗？如果不是，举例说明

不一定

比如只增加很少块时，同一地址第二次访问时，仍然存在第一次写入的数据被替换，所以每次访问都重新写入，所以命中率不变
