# COD WEEK5



## T1

### （1）

> 题目 1. 计算题：假设能保存5位有效数位并且指数的表示范围与IEEE 754标准单精度浮点数相同 
>
> 1.将1.062510和−0.687510用十进制科学计数法表示后计算浮点加法

$1.0625\times10^0+(-6.875\times10^{-1})$

=$0.3750\times10^0$

=$3.7500\times10^{-1}$



### （2）

> 2.将1.062510和−0.687510用二进制科学计数法表示后计算浮点加法

$1.0625=1.0001\times2^0$

$-0.6875=(-1.0110\times2^{-1})$

相加得：$0.0110\times2^0=1.1000\times2^{-2}$





## T2

> ![image-20230426105528464](C:\Users\Nutrition\AppData\Roaming\Typora\typora-user-images\image-20230426105528464.png)
>
> 1. R型指令的延迟是多少？ 
> 2. ld指令的延迟是多少？ 
> 3. sd指令的延迟是多少？ 
> 4. beq指令的延迟是多少？ 
> 5. I型指令(不考虑存储器)的延迟是多少？ 
> 6. 该CPU的最小时钟周期是多少？

- R：		30ps+250ps+150ps+25ps+200ps+25ps+20ps=700ps 
- ld：      30ps+250ps+150ps+200ps+250ps+25ps+20ps=925ps 
- sd：     30ps+250ps+150ps+200ps+250ps=880ps 
- beq：   30ps+250ps+150ps+25ps+200ps+5ps+25ps=685ps 
- I：       700ps-25ps=675ps 
- ​       	925s





## 实验题

> 假设从t0所保存的地址开始的八个字节存储了一个IEEE 754标准的双精度浮点数，使用RV32I指令读取该双精度浮点数，将其转换为IEEE 754标准的单精度浮点数后 存储在t1所指向的地址中。（尾数部分可以直接截断，不用考虑指数部分的溢出，双精度浮点数以小端序存储）

```assembly
lw t2, 0(t0)      	# 从t0所指向的地址读取双精度浮点数的低4字节
lw t3, 4(t0)      	# 从t0所指向的地址读取双精度浮点数的高4字节


srli t4, t3, 20   	# 将双精度的高4字节右移20位，得到单精度浮点数的指数部分
andi t5, t4, 0x7ff 	# 从单精度的指数部分中提取11位指数位
addi t5, t5, -1023 	# 减去双精度的偏置值
addi t5, t5, 127   	# 加上单精度的偏置值，得到单精度浮点数的指数部分
slli x11, t5, 23   	# 将指数部分左移23位，得到单精度指数部分

srli x12, t3, 31	# 获取双精度符号位
slli x12, x12,31	# 得到单精度符号位
or t5, t5, x12		# 符号位和指数部分合并

slli t3, t3, 12    	# 将双精度的高4字节左移12位，得到双精度的尾数部分的前20位
srli t3, t3, 9     	# 将尾数部分的前20位右移9位，得到单精度的尾数部分的前20位
srli t2, t2, 29		# 将双精度的低4字节右移29位，得到后三位
add  t3, t3, t2     # 后三位与前20位合并，得到尾数部分

or t4, x11, t3    	# 符号位和指数部分和尾数部分合并，得到单精度浮点数

sw t4, 0(t1)      	# 将单精度存储到t1所指向的地址中
```

